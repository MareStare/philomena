{
  "build": {
    "dockerfile": "../docker/app/Dockerfile",
    "context": "..",
    "args": {
      "WORKSPACE": "${localWorkspaceFolder}",
      "USER": "${localEnv:USER:philomena}"
    }
  },

  // While technically optional, `init` enables an init process to properly handle
  // signals and ensure Zombie Processes are cleaned up.
  "init": true,

  // Create the `philomena` network if it doesn't exist. This network is shared
  // with other docker containers spawned by the devcontainer.
  // "initializeCommand": "docker network inspect philomena >/dev/null 2>&1 || docker network create philomena",
  "runArgs": ["--network=host"],

  // The devcontainer is on the same network as our main app docker compose services,
  // which means that that other containers are available by their service names.
  "forwardPorts": ["localhost:5173", "localhost:8080"],

  "mounts": [
    // Use a "docker outside of docker" setup where we reuse the host's docker daemon:
    // https://github.com/microsoft/vscode-dev-containers/tree/main/containers/docker-from-docker
    {
      "source": "/var/run/docker.sock",
      "target": "/var/run/docker.sock",
      "type": "bind"
    }
  ],

  // Mount the repository at the same path as it is on the host within the container.
  // This is needed to work around the problem that some tools like `docker compose`
  // and Docker VSCode extension don't specially handle the devcontainer environment
  // with the "docker-outside-of-docker" setup. For example if we use relative paths
  // in `docker-compose.yml`, then they'll be sent to the host's docker daemon using
  // the paths canonicalized within the devcontainer's view of the file system, which
  // will be different from the host's view of the mount. Having the host and the
  // devcontainer use the same path to the workspace fixes this and simplifies our life.
  "workspaceMount": "source=${localWorkspaceFolder},target=${localWorkspaceFolder},type=bind",
  "workspaceFolder": "${localWorkspaceFolder}",

  "containerEnv": {
    "WORKSPACE": "${localWorkspaceFolder}"
  },

  // Make sure our custom `docker-init.sh` script is run at startup
  "overrideCommand": false,

  "customizations": {
    "vscode": {
      "settings": {
        // Rust Analyzer struggles to discover the cargo workspace unless there
        // is a `Cargo.toml` in the repo root. So, we give it a small hint.
        "rust-analyzer.linkedProjects": ["./native/philomena/Cargo.toml"],

        // VSCode seems to do a pretty bad job of auto-inferring the forwarded ports.
        // We declare the ports of interest explicitly anyway, so we don't need this.
        "remote.autoForwardPorts": false,

        // Listen on `0.0.0.0` on the local machine to allow for access the site
        // on the local network, e.g. via WiFi and a phone
        "remote.localPortHost": "allInterfaces"
      },
      "extensions": [
        // Elixir LSP
        "lexical-lsp.lexical",

        // Rust LSP
        "rust-lang.rust-analyzer",

        // TOML LSP
        "tamasfe.even-better-toml",

        // Dockerfile LSP
        "ms-azuretools.vscode-docker",

        // Github Actions LSP
        "github.vscode-github-actions",

        // Bash LSP
        "mads-hartmann.bash-ide-vscode",

        // `.slime` syntax highlighting
        "xolan.slime",

        // `.js`, `.ts` linter
        "dbaeumer.vscode-eslint",

        // `.css` linter
        "stylelint.vscode-stylelint",

        // `.js`, `.ts`. `.css`, `.json`, `.yaml`, `.md` formatter
        "esbenp.prettier-vscode",

        // Spell checker enforced on CI
        "tekumara.typos-vscode",

        // `.toMatchInlineSnapshot()` syntax highlighting
        "tlent.jest-snapshot-language-support"
      ]
    }
  }
}
